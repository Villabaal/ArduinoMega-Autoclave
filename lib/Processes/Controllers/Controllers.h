#include <Doors.h>
#include <Generators.h>
#include "Meassures.h"
#include "Alarm.h"
#include "Actuators.h"

#pragma once
#ifndef _BProcesses_H_
#define _BProcesses_H_

//usa el timer 5
namespace Processes{

    template<class CMPS> concept hasDoor = !std::same_as<typename CMPS::Door,void>;
    template<class CMPS> concept hasGenerator = !std::same_as<typename CMPS::Generator,void>;
    template<class CMPS> concept autogeneratedWithDoor = hasDoor<CMPS>&&hasGenerator<CMPS>;

    static constexpr uint8_t  PresExMin  {40};              // minima presion Ext. para iniciar el proceso
    static constexpr uint16_t SampleInterval {500};   
    
    template< class CMPS > struct Controller{
        static inline uint8_t Errors {0};
        static inline uint8_t state_ { Free };
        // using Peri = Peripherals;
        static inline RelayVector relays { Valvs };         
        static void init(){
            pinMode(led,OUTPUT); digitalWrite(led,LOW); 
            timer::setInterval(SampleInterval); 
            timer::isr = [](){  digitalWrite(led,!digitalRead(led)); stages[ state_ ](); };
        }        
        static void  sterilization(uint16_t const& Tsterilization, uint16_t const& Tdrying, const float& tempSetpoint){
            TSterilization = Tsterilization*alpha; TDrying = Tdrying*alpha; TempSetpoint = tempSetpoint;
            timer::enableTimer(); state_ = Prewarm;  pulseState = true;                           //Prewarm 'P'
            relays[EST](true); relays[EM](true); relays[ENA](false);
        }
        static void jump(){
            if (state_ == Prewarm){                                                    //prevacio
                counterAux = 0; counter = 0; state_ = Warm;
                relays[EST](true); relays[EM](true); relays[SEC](false);
                return;
            }
            if ( (state_ == Warm) || (state_ == Sterelization)){                         //calentamiento o esterilizacion
                counter = 0;  state_ = Expulsion;                                                     //Expulsion
                relays[EST](false); relays[EM](false);
                relays[ESL](true); return;
            }
            if (state_ == Drying){                                              //secado
                counter = 0; counterAux = 0; state_ = Finish;
                relays[SEC](false); relays[ENA](true);  
            }                
        }
        static void abort(){    
            relays.clear_all();  digitalWrite(led,LOW);                          //apaga perifericos
            timer::stopTimer(); state_ = Free;
        }
        static uint16_t countDown(){ 
            if (state_ == Sterelization){ return TSterilization - counter ; }
            if (state_ == Drying){ return TDrying - counter ; }
            if (state_ == Finish){ return FinisT - counter ; }
            return 0;
        }
        
    private:      
        using alarm = Alarms::Alarm;
        using timer = Timer<5>;
        using sensors = Meassures::AnalogMeassures;
        //lista de parametros de procesos (por renglon)
        static constexpr uint16_t alpha      {120};             //60 segundos x 2 (periodo de muestreo 0.5)
        static constexpr uint16_t Tsucc     {2*15};            //15 segundos
        static constexpr uint16_t Tena      {2*15};            //15 segundos
        static constexpr uint8_t  pulses      {1};
        // tiempos de tolerancia
        static constexpr uint16_t PreWarmT   {1200};          
        static constexpr uint16_t WarmT      {1800};           //(1800) 900s = 15m, tolerancia de 15m para llenar camara interior
        static constexpr uint16_t FillingT   {1200};           //(1200) 600s = 10m, tolerancia de 10m para llenar camara exterior
        static constexpr uint16_t ExpulsionT {1200};           //10m, tolerancia para que la camara interna se despresurice
        static constexpr uint16_t FinisT     {600};
        //estaticas (cambian solo al inicio del proceso)
        static inline uint16_t TSterilization{};    
        static inline uint16_t TDrying {};        
        static inline float TempSetpoint {};        
        //volatil
        //volatiles (cambiando durante el proceso)
        static inline uint16_t counter {0},counterAux {0};
        static inline bool pulseState {false};     
        //etapas
        static constexpr void( *const stages[] )() {
            [](){ // Prewarm 'P'
            timerHandler( counter,PreWarmT , 
                [](){   //control de histeresis
                    if ((sensors::internal_pressure_() >= 10)&&(pulseState)){
                        relays[EST](false); relays[EM](false); 
                        relays[SEC](true); pulseState = false;
                    }
                    else if (( sensors::internal_pressure_() <= 5 )&&(!pulseState)){
                        relays[EST](true); relays[SEC](false);
                        counterAux++; pulseState = true;
                    }
                    if ( counterAux == pulses ){  //Succiona el aire externo inicial 1 vez
                        state_ = Warm; /* 'C' */ counter = 0; counterAux = 0;
                    }        
                },
                [](){ bitSet(Errors,E4); } //se termino el tiempo de tolerancia
            );  
                     
            },
            [](){ //Calentamiento 'C'
                timerHandler(counter , WarmT,
                    [](){
                        if( counter == 10 ) relays[EM](false);           //10 segundos de sellado de puerta          
                        if ( (sensors::internal_pressure_() >= 35) ){
                            counter = 0; relays[EST](false); state_ = Sterelization; /* 'E' */
                        } 
                    },
                    [](){ bitSet(Errors,E3); }//Error en camara Interior
                );                
            },
            [](){ //Sterilization 'E'
                timerHandler(counter , TSterilization,
                    [](){    //control de histeresis
                        if ( relays[EM] ) relays[EM](false);
                        if (  sensors::internal_temp_() < (TempSetpoint - 2.5) ){
                            relays[EST](true);   //abre la valvula de vapor
                        }
                        else if (  sensors::internal_temp_() >= (TempSetpoint + 2.5) ){
                            relays[EST](false); //cierra la valvula de vapor
                        }
                        if ( sensors::internal_pressure_() < 25 ){
                            bitSet(Errors,E0);                             //Error en Esterilizacion
                        }           
                    },
                    [](){  //al terminar la ceunta
                        relays[EST](false);  relays[ESL](true);                         
                        state_ = Expulsion; /* 'X' */                      //Expulsion
                    }
                );                
            },
            [](){  //Expulsion 'X'
                timerHandler(counter,ExpulsionT,
                    [](){
                        if ( (sensors::internal_pressure_() <= 5)  ){                 //esta despresurizada la camara?
                            counter = 0 ; relays[ESL](false);                     //reinicia la cuenta
                            if (sensors::external_pressure_() < PresExMin ) {  state_ = Refill; /* 'R' */ return; }     //pausa de rellenado
                            relays[SEC](true);  state_ = Drying; /* 'S' */
                        }
                    },
                    [](){ bitSet(Errors,E5); } //Error en camara despresurizacion
                );                
            },
            [](){  //Refill 'R'
                timerHandler(counter, FillingT , 
                    [](){
                        if ( (sensors::external_pressure_() >= PresExMin)  ){         //presion suficiente
                            counter = 0 ;  state_ = Drying; /* 'S' */                            //reinicia la cuenta
                            relays[SEC](true);
                        }          
                    },
                    [](){ bitSet(Errors,E6); } //se acabo el tiempo de tolerancia
                );                 
            },
            [](){ //Drying  'S'
                timerHandler(counter, TDrying, 
                    [](){
                        if ( relays[SEC] ){
                            timerHandler(counterAux , Tsucc, [](){
                            relays[SEC](false); relays[ENA](true);
                            }); return;
                        }
                        if ( relays[ENA] )  
                            timerHandler(counterAux , Tena, [](){
                            relays[SEC](true); relays[ENA](false);
                            });                       
                    }, 
                    [](){                                            //termina el tiempo de secado
                        relays[SEC](false); relays[ENA](true);
                        state_ = Finish; counterAux = 0;/* 'T' */ 
                    }
                );                
            },
            [](){  //Finishing 'T'
                timerHandler(counter ,FinisT, [](){
                    digitalWrite(led,LOW);                                  //apaga el led
                    timer::stopTimer();                               //detiene el temporizador
                    alarm::turnOn();                                  //enciende la alarma
                    state_ = Free;                                             //ya no esta ocupado
                    relays[ENA](false);
                });                
            }
        }; 
    };    
}
#endif