#include <Systems.h>

namespace Comm{
    // buzzer de 12v
    using alarm = Alarms::Alarm;
    //Mediciones analogicas
    using sensores = Meassures::AnalogMeassures;
    //procesa los inputs dado la especializacion de el proceso
    template< class PROCESS > struct input_org {
        using Door = PROCESS::cmps::Door;
        using Generator = PROCESS::cmps::Generator;
        using process = PROCESS;
    };

    template<class In> using enable_GeneratorAndDoor = std::enable_if_t< Processes::autogeneratedWithDoor< In > >;
    template<class In> using enable_hasGenerator = std::enable_if_t< Processes::hasGenerator< In > >;

    
    template< class INPUTS > struct Init{
        static inline uint8_t Errors_ {0};
        static void init( ){ 
            if constexpr( Processes::hasDoor<INPUTS> ) 
                INPUTS::Door::init();           //inicia los perifericos y timers de la puerta
            sensores::init();
            alarm::init();  
            INPUTS::process::init();         //prepara los perofericos del autoclave 
            Serial1.begin(4800); 
            while (Serial1.available() == 0);   
            if constexpr ( Processes::hasGenerator<INPUTS> ){               
                uint8_t&& req = Serial1.read();         
                if( req == 'M') {  Serial1.write( aceptar ); return; }       //Modo manual
                if( req == 'A') {                                            //Modo automatico
                    if( INPUTS::Generator::level_encoder() != 0 ){ 
                        Serial1.write(aceptar);
                        INPUTS::Generator::turnOn();
                        return;
                    }
                    bitSet(Errors_,E2);
                    Serial1.write( error );
                    Serial1.write( Errors_ );    
                }
            }
            else{ Serial1.read(); Serial1.write( aceptar ); }
        }
    };

    template< class INPUTS > class SetUp{};
    template< Processes::hasGenerator INPUTS > class SetUp<INPUTS>{
    public:
        //SFINAE overloading
        template< class CNTLType = INPUTS::Generator::cmps::ControlType , class = Generators::enable_notfit<CNTLType> >
        static void setup_( uint8_t&& WT ,uint8_t&& OFT ){
            INPUTS::Generator::init( std::move(WT) , std::move(OFT) ); 
            Init<INPUTS>::init();
        }
        template< class CNTLType = INPUTS::Generator::cmps::ControlType , class = Generators::enable_fit<CNTLType> >
        static void setup_( uint8_t&& WT  ){   
            INPUTS::Generator::init( std::move(WT) ); 
            Init<INPUTS>::init();
        }        
    };

    template< class INPUTS > class Loop{
        //SFINAE overloading
        template< class In = INPUTS , class = enable_GeneratorAndDoor<In>  >
        static constexpr void ( *request_[] ) ( const uint8_t& ) {
            []( const uint8_t& req ){ 
                if(( alarm::state )&&( req == abrirPuerta )) alarm::turnOff(); In::Door::request(req); 
            },
            sensores::request, alarm::request, In::Generator::request, In::process::request
        };        

        static constexpr auto& Errors = Init< INPUTS >::Errors_;  

    public:
        static void loop_(){   
            //alguna peticion?
            if ( (Serial1.available() > 0)&&( Errors == 0) ){
                uint8_t&& req = Serial1.read();
                request_<>[ req/10 ]( req%10 );
            }
            //errores en los sistemas automaticos?
            if constexpr ( Processes::hasGenerator<INPUTS> )
                Errors |= ( INPUTS::process::Errors | INPUTS::Generator::Errors );
            else 
                Errors |= INPUTS::process::Errors;
            
            //si hay algun error en algun componente
            if (Errors > 0){
                if ( (Serial1.available() > 0)  ){
                Serial1.read();
                Serial1.write( error );
                Serial1.write( Errors );
                }  
                if constexpr ( Processes::hasGenerator<INPUTS> ) 
                    if ( INPUTS::Generator::state ) INPUTS::Generator::turnOff();
                if ( INPUTS::process::state != Free ) INPUTS::process::abort();
                if ( !alarm::state ) alarm::turnOn(500,50); // frenetica
            }
        }
    };   
      

    template< class PROCESS > struct Port{
        static constexpr auto& loop = Loop< input_org< PROCESS > >::loop_ ;
        static constexpr auto& setup = SetUp< input_org< PROCESS > >::template setup_<>;
    };
    

}